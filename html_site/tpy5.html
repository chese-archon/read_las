<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Cloud Viewer</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Получаем данные точек из контекста Django
        const pointsData = JSON.parse('{{ points|escapejs }}');

        // Создаем сцену, камеру и рендерер
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer();
        document.body.appendChild(renderer.domElement);

        // Обновление размера canvas для квадрата
        function updateCanvasSize() {
    var canvas = renderer.domElement;

    // Устанавливаем новые размеры canvas (высота равна ширине)
    var newWidth = window.innerWidth * 0.8;
    var newHeight = newWidth; // Высота равна ширине

    // Учитываем, чтобы высота не превышала высоту окна
    if (newHeight > window.innerHeight * 0.8) {
        newHeight = window.innerHeight * 0.8;
        newWidth = newHeight; // Ширина тоже будет равна высоте
    }

        // Инициализация размера canvas и обработчик изменения размеров окна
        updateCanvasSize();
        window.addEventListener('resize', updateCanvasSize);

        // Создаем геометрию облака точек
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];

        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

        pointsData.forEach(point => {
            if (point.x < minX) minX = point.x;
            if (point.y < minY) minY = point.y;
            if (point.z < minZ) minZ = point.z;
            if (point.x > maxX) maxX = point.x;
            if (point.y > maxY) maxY = point.y;
            if (point.z > maxZ) maxZ = point.z;
        });

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const centerZ = (minZ + maxZ) / 2;
        const scale = 0.1;

        pointsData.forEach(point => {
            vertices.push(
                (point.x - centerX) * scale,
                (point.y - centerY) * scale,
                (point.z - centerZ) * scale
            );
            colors.push(point.r, point.g, point.b);
        });

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // Настраиваем материал точек
        const material = new THREE.PointsMaterial({
            vertexColors: true,
            size: 0.05,
            sizeAttenuation: true
        });
        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // Позиционируем камеру
        const maxDistance = Math.max(maxX - minX, maxY - minY, maxZ - minZ) * scale;
        camera.position.set(0, 0, maxDistance * 2);
        camera.lookAt(0, 0, 0);

        // Вращение сцены с помощью мыши
        let isMouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;

        renderer.domElement.addEventListener('mousedown', function (event) {
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        renderer.domElement.addEventListener('mouseup', function () {
            isMouseDown = false;
        });

        renderer.domElement.addEventListener('mousemove', function (event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;

            scene.rotation.y += deltaX * 0.005;
            scene.rotation.x += deltaY * 0.005;

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>

